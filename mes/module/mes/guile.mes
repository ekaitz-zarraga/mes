;;; -*-scheme-*-

;;; GNU Mes --- Maxwell Equations of Software
;;; Copyright Â© 2016,2017,2018,2019,2021 Jan (janneke) Nieuwenhuizen <janneke@gnu.org>
;;;
;;; This file is part of GNU Mes.
;;;
;;; GNU Mes is free software; you can redistribute it and/or modify it
;;; under the terms of the GNU General Public License as published by
;;; the Free Software Foundation; either version 3 of the License, or (at
;;; your option) any later version.
;;;
;;; GNU Mes is distributed in the hope that it will be useful, but
;;; WITHOUT ANY WARRANTY; without even the implied warranty of
;;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;;; GNU General Public License for more details.
;;;
;;; You should have received a copy of the GNU General Public License
;;; along with GNU Mes.  If not, see <http://www.gnu.org/licenses/>.

;;; Commentary:

;;; Code:

(define-macro (cond-expand-provide . rest) #t)

(define-macro (include-from-path file)
  (let loop ((path (cons* %moduledir "module" (string-split (or (getenv "GUILE_LOAD_PATH") "") #\:))))
    (cond ((and=> (getenv "MES_DEBUG") (compose (lambda (o) (> o 2)) string->number))
           (core:display-error (string-append "include-from-path: " file " [PATH:" (string-join path ":") "]\n")))
          ((and=> (getenv "MES_DEBUG") (compose (lambda (o) (> o 1)) string->number))
           (core:display-error (string-append "include-from-path: " file "\n"))))
    (if (null? path) (error "include-from-path: not found: " file)
        (let ((file (string-append (car path) "/" file)))
          (if (access? file R_OK) `(load ,file)
              (loop (cdr path)))))))

(define-macro (define-module module . rest)
  `(if ,(and (pair? module)
             (= 1 (length module))
             (symbol? (car module)))
       (define (,(car module) . arguments) (main (command-line)))))

(define-macro (defmacro name args . body)
  `(define-macro ,(cons name args) ,@body))

(define-macro (set-object-property! object key value)
  object)

(define-macro (set-procedure-property! proc key value)
  proc)

(define-macro (use-modules . rest) #t)

(define (effective-version) %version)

(define %load-path (or (and=> (getenv "GUILE_LOAD_PATH") (lambda (x) (string-split x #\:))) '()))

(define (object->string x . rest)
  (with-output-to-string
    (lambda () ((if (pair? rest) (car rest) write) x))))

(define (port-filename p) "<stdin>")
(define (port-line p) 0)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Hacks for Nyacc with modules
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;; Strings/srfi-13
(define reverse-list->string (compose list->string reverse))
(define string-null? (compose null? string->list))


;;; Char-sets/srfi-14
;; FIXME: have structs
(define (char-set . x)
  (cons '*char-set* x))

(define char-set:whitespace (char-set #\tab #\page #\return #\vtab #\newline #\space))

(define (string->char-set x . base)
  (apply char-set (append (string->list x) (if (null? base) '() (cdar base)))))

(define (string->char-set! x base)
  (set-cdr! (last-pair base) (string->list x))
  base)

(define (char-set-copy cs)
  (map identity cs))

(define (list->char-set lst)
  (apply char-set lst))


;;; ice-9 optargs/macros
(define (rest-arg->keyword-binding-list rest-arg keywords allow-other-keys?)
  (if (null? rest-arg)
      '()
      (let loop ((first (car rest-arg))
		 (rest (cdr rest-arg))
		 (accum '()))
	(let ((next (lambda (a)
		      (if (null? (cdr rest))
			  a
			  (loop (cadr rest) (cddr rest) a)))))
	  (if (keyword? first)
	      (cond
	       ((memq first keywords)
		(if (null? rest)
                    (error "Keyword argument has no value:" first)
		    (next (cons (cons (keyword->symbol first)
				      (car rest)) accum))))
	       ((not allow-other-keys?)
                (error "Unknown keyword in arguments:" first))
	       (else (if (null? rest)
			 accum
			 (next accum))))
	      (if (null? rest)
		  accum
		  (loop (car rest) (cdr rest) accum)))))))

;; (define (make-ident-like-p . rest)
;;   (warn "fubar: make-ident-like-p" rest))

;; (define (make-comm-reader . rest)
;;   (warn "fubar: make-comm-reader" rest))

;; (define (make-lexer-generator . rest)
;;   (warn "fubar: make-lexer-generator" rest))

;; (define (move-attributes . rest)
;;   (warn "fubar: move-attributes" rest))

;; (define (read-c-ident . rest)
;;   (warn "fubar: read-c-ident" rest))

;; (define (filter-mt . rest)
;;   (warn "fubar: filter-mt" rest))

;; (define (map-mt . rest)
;;   (warn "fubar: map-mt" rest))

;; (define (remove-mt . rest)
;;   (warn "fubar: remove-mt" rest))

;; (define (make-chseq-reader . rest)
;;   (warn "fubar: make-chseq-reader" rest))

;; (define (count-opt . rest)
;;   (warn "fubar: count-opt" rest))

;; (define (read-c-chlit . rest)
;;   (warn "fubar: read-c-chlit" rest))

;; (define (read-c-num . rest)
;;   (warn "fubar: read-c-num" rest))

;; (define (make-lalr-parser . rest)
;;   (warn "fubar: make-lalr-parser" "..."))

;; (define (c99-len-v . rest)
;;   (warn "fubar: c99-len-v" rest))


;; (define (filter pred lst)
;;   (let loop ((lst lst))
;;     (if (null? lst) '()
;;         (if (pred (car lst))
;;             (cons (car lst) (loop (cdr lst)))
;;             (loop (cdr lst))))))

;; (define (multi-opt option-name) (lambda (o) (and (eq? (car o) option-name) (cdr o))))

;; (define (count-opt options option-name)
;;   (let ((lst (filter identity (map (multi-opt option-name) options))))
;;     (and (pair? lst) (length lst))))
